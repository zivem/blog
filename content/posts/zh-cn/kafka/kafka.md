## Kafka 作为一个分布式的流平台，这到底意味着什么？

我们认为，一个流处理平台具有三个关键能力：

1. 发布和订阅消息(流)，在这方面，它类似于一个消息队列。
2. 以容错(故障转移)的方式存储消息(流)。
3. 在消息流发生时处理它们。

### 什么是 kafka 的优势？它主要应用于 2 大类应用：

 #数据管道#​

助记词：

‍

#转换或反应#

1. 构建实时的流数据管道，可靠地获取系统和应用程序之间的数据。
2. 构建实时流的应用程序，对数据流进行转换或反应。

要了解 kafka 是如何做这些事情的，让我们从下到上深入探讨 kafka 的能力。

### 首先几个概念：

1. kafka 作为一个集群运行在一个或多个服务器上。
2. kafka 集群存储的消息是以 topic 为类别记录的。
3. 每个消息（也叫记录 record，我习惯叫消息）是由一个 key，一个 value 和时间戳构成。

### kafka 有四个核心 API：

* 应用程序使用 [Producer API](/190) 发布消息到 1 个或多个 topic（主题）中。
* 应用程序使用 [Consumer API](/200) 来订阅一个或多个 topic，并处理产生的消息。
* 应用程序使用 [Streams API](/304) 充当一个流处理器，从 1 个或多个 topic 消费输入流，并生产一个输出流到 1 个或多个输出 topic，有效地将输入流转换到输出流。
* [Connector API](/455) 可构建或运行可重用的生产者或消费者，将 topic 连接到现有的应用程序或数据系统。例如，连接到关系数据库的连接器可以捕获表的每个变更。

![kafka 入门介绍](assets/net-img-KmCudlf7DXiAVXBMAAFScKNS-Og538-20220619190842-uooujnf.png)

Client 和 Server 之间的通讯，是通过一条简单、高性能并且和开发语言无关的 [TCP协议](/fwd?link=https://kafka.apache.org/protocol.html)。并且该协议保持与老版本的兼容。Kafka 提供了 Java Client（客户端）。除了 Java 客户端外，还有非常多的[其它编程语言的客户端](/fwd?link=https://cwiki.apache.org/confluence/display/KAFKA/Clients)。

## 首先来了解一下 Kafka 所使用的基本术语：

#### Topic

Kafka 将消息分门别类，每一类的消息称之为一个主题（Topic）。

#### Producer

发布消息的对象称之为主题生产者（Kafka topic producer）

#### Consumer

订阅消息并处理发布的消息的对象称之为主题消费者（consumers）

#### Broker

已发布的消息保存在一组服务器中，称之为 Kafka 集群。集群中的每一个服务器都是一个代理（Broker）。 消费者可以订阅一个或多个主题（topic），并从 Broker 拉数据，从而消费这些已发布的消息。

## 主题和日志 （Topic 和 Log）

让我们更深入的了解 Kafka 中的 Topic。

Topic 是发布的消息的类别名，一个 topic 可以有零个，一个或多个消费者订阅该主题的消息。

对于每个 topic，Kafka 集群都会维护一个分区 log，就像下图中所示：

![kafka topic 剖析](assets/net-img-KmCudlf7DsaAVF0WAABMe0J0lv4158-20220619190842-jaz9zt7.png)

每一个分区都是一个顺序的、不可变的消息队列， 并且可以持续的添加。分区中的消息都被分了一个序列号，称之为偏移量(offset)，在每个分区中此偏移量都是唯一的。

Kafka 集群保持所有的消息，直到它们过期（无论消息是否被消费）。实际上消费者所持有的仅有的元数据就是这个 offset（偏移量），也就是说 offset 由消费者来控制：正常情况当消费者消费消息的时候，偏移量也线性的的增加。但是实际偏移量由消费者控制，消费者可以将偏移量重置为更早的位置，重新读取消息。可以看到这种设计对消费者来说操作自如，一个消费者的操作不会影响其它消费者对此 log 的处理。

![kafka offset 偏移量](assets/net-img-KmCudlf7D2iALXG_AAIhinsLf_Q676-20220619190842-x1lg5gz.png)

再说说分区。Kafka 中采用分区的设计有几个目的。一是可以处理更多的消息，不受单台服务器的限制。Topic 拥有多个分区意味着它可以不受限的处理更多的数据。第二，分区可以作为并行处理的单元，稍后会谈到这一点。

## 分布式(Distribution)

Log 的分区被分布到集群中的多个服务器上。每个服务器处理它分到的分区。 根据配置每个分区还可以复制到其它服务器作为备份容错。 每个分区有一个 leader，零或多个 follower。Leader 处理此分区的所有的读写请求，而 follower 被动的复制数据。如果 leader 宕机，其它的一个 follower 会被推举为新的 leader。 一台服务器可能同时是一个分区的 leader，另一个分区的 follower。 这样可以平衡负载，避免所有的请求都只让一台或者某几台服务器处理。

## Geo-Replication(异地数据同步技术)

‍

Kafka MirrorMaker 为群集提供 `geo-replication` 支持。借助 `MirrorMaker`，消息可以跨多个数据中心或云区域进行复制。 您可以在 active/passive 场景中用于备份和恢复; 或者在 active/passive 方案中将数据置于更接近用户的位置，或数据本地化。

## 生产者(Producers)

生产者往某个 Topic 上发布消息。生产者也负责选择发布到 Topic 上的哪一个分区。最简单的方式从分区列表中轮流选择。也可以根据某种算法依照权重选择分区。开发者负责如何选择分区的算法。

## 消费者(Consumers)

通常来讲，消息模型可以分为两种， 队列和发布-订阅式。 队列的处理方式是 一组消费者从服务器读取消息，一条消息只有其中的一个消费者来处理。在发布-订阅模型中，消息被广播给所有的消费者，接收到消息的消费者都可以处理此消息。Kafka 为这两种模型提供了单一的消费者抽象模型： 消费者组 （consumer group）。 消费者用一个消费者组名标记自己。 一个发布在 Topic 上消息被分发给此消费者组中的一个消费者。 假如所有的消费者都在一个组中，那么这就变成了 queue 模型。 假如所有的消费者都在不同的组中，那么就完全变成了发布-订阅模型。 更通用的， 我们可以创建一些消费者组作为逻辑上的订阅者。每个组包含数目不等的消费者， 一个组内多个消费者可以用来扩展性能和容错。正如下图所示：

![kafka 消费者](assets/net-img-KmCudlf7D-OAEjy8AABoxGLnMI4173-20220619190842-a974zh8.png)

2 个 kafka 集群托管 4 个分区（P0-P3），2 个消费者组，消费组 A 有 2 个消费者实例，消费组 B 有 4 个。

正像传统的消息系统一样，Kafka 保证消息的顺序不变。 再详细扯几句。传统的队列模型保持消息，并且保证它们的先后顺序不变。但是， 尽管服务器保证了消息的顺序，消息还是异步的发送给各个消费者，消费者收到消息的先后顺序不能保证了。这也意味着并行消费将不能保证消息的先后顺序。用过传统的消息系统的同学肯定清楚，消息的顺序处理很让人头痛。如果只让一个消费者处理消息，又违背了并行处理的初衷。 在这一点上 Kafka 做的更好，尽管并没有完全解决上述问题。 Kafka 采用了一种分而治之的策略：分区。 因为 Topic 分区中消息只能由消费者组中的唯一一个消费者处理，所以消息肯定是按照先后顺序进行处理的。但是它也仅仅是保证 Topic 的一个分区顺序处理，不能保证跨分区的消息先后处理顺序。 所以，如果你想要顺序的处理 Topic 的所有消息，那就只提供一个分区。

## Kafka 的保证(Guarantees)

* 生产者发送到一个特定的 Topic 的分区上，消息将会按照它们发送的顺序依次加入，也就是说，如果一个消息 M1 和 M2 使用相同的 producer 发送，M1 先发送，那么 M1 将比 M2 的 offset 低，并且优先的出现在日志中。
* 消费者收到的消息也是此顺序。
* 如果一个 Topic 配置了复制因子（replication factor）为 N， 那么可以允许 N-1 服务器宕机而不丢失任何已经提交（committed）的消息。

有关这些保证的更多详细信息，请参见文档的设计部分。

## kafka 作为一个消息系统

##### Kafka 的流与传统企业消息系统相比的概念如何？

传统的消息有两种模式：`队列` 和 `发布订阅`。 在队列模式中，消费者池从服务器读取消息（每个消息只被其中一个读取）; 发布订阅模式：消息广播给所有的消费者。这两种模式都有优缺点，队列的优点是允许多个消费者瓜分处理数据，这样可以扩展处理。但是，队列不像多个订阅者，一旦消息者进程读取后故障了，那么消息就丢了。而 `发布和订阅` 允许你广播数据到多个消费者，由于每个订阅者都订阅了消息，所以没办法缩放处理。

kafka 中消费者组有两个概念：`队列`：消费者组（consumer group）允许同名的消费者组成员瓜分处理。`发布订阅`：允许你广播消息给多个消费者组（不同名）。

kafka 的每个 topic 都具有这两种模式。

##### kafka 有比传统的消息系统更强的顺序保证。

传统的消息系统按顺序保存数据，如果多个消费者从队列消费，则服务器按存储的顺序发送消息，但是，尽管服务器按顺序发送，消息异步传递到消费者，因此消息可能乱序到达消费者。这意味着消息存在并行消费的情况，顺序就无法保证。消息系统常常通过仅设 1 个消费者来解决这个问题，但是这意味着没用到并行处理。

kafka 做的更好。通过并行 topic 的 parition —— kafka 提供了顺序保证和负载均衡。每个 partition 仅由同一个消费者组中的一个消费者消费到。并确保消费者是该 partition 的唯一消费者，并按顺序消费数据。每个 topic 有多个分区，则需要对多个消费者做负载均衡，但请注意，`相同的消费者组中不能有比分区更多的消费者，否则多出的消费者一直处于空等待，不会收到消息`。

## kafka 作为一个存储系统

所有发布消息到 `消息队列` 和消费分离的系统，实际上都充当了一个存储系统（发布的消息先存储起来）。Kafka 比别的系统的优势是它是一个非常高性能的 `存储系统`。

写入到 kafka 的数据将写到磁盘并复制到集群中保证容错性。并允许生产者等待消息应答，直到消息完全写入。

kafka 的磁盘结构 - 无论你服务器上有 50KB 或 50TB，执行是相同的。

client 来控制读取数据的位置。你还可以认为 kafka 是一种专用于高性能，低延迟，提交日志存储，复制，和传播特殊用途的 `分布式文件系统`。

## kafka 的流处理

仅仅读，写和存储是不够的，kafka 的目标是实时的流处理。

在 kafka 中，流处理持续获取 `输入topic` 的数据，进行处理加工，然后写入 `输出topic`。例如，一个零售 APP，接收销售和出货的 `输入流`，统计数量或调整价格后输出。

可以直接使用 producer 和 consumer API 进行简单的处理。对于复杂的转换，Kafka 提供了更强大的 Streams API。可构建 `聚合计算` 或 `连接流到一起` 的复杂应用程序。

助于解决此类应用面临的硬性问题：处理无序的数据，代码更改的再处理，执行状态计算等。

Streams API 在 Kafka 中的核心：使用 producer 和 consumer API 作为输入，利用 Kafka 做状态存储，使用相同的组机制在 stream 处理器实例之间进行容错保障。

## 拼在一起

消息传递，存储和流处理的组合看似反常，但对于 Kafka 作为流式处理平台的作用至关重要。

像 HDFS 这样的分布式文件系统允许存储静态文件来进行批处理。这样系统可以有效地存储和处理来自过去的历史数据。

传统企业的消息系统允许在你订阅之后处理未来的消息：在未来数据到达时处理它。

Kafka 结合了这两种能力，这种组合对于 kafka 作为流处理应用和流数据管道平台是至关重要的。

批处理以及消息驱动应用程序的流处理的概念：通过组合存储和低延迟订阅，流处理应用可以用相同的方式对待过去和未来的数据。它是一个单一的应用程序，它可以处理历史的存储数据，当它处理到最后一个消息时，它进入等待未来的数据到达，而不是结束。

同样，对于流数据管道（pipeline），订阅实时事件的组合使得可以将 Kafka 用于非常低延迟的管道；但是，可靠地存储数据的能力使得它可以将其用于必须保证传递的关键数据，或与仅定期加载数据或长时间维护的离线系统集成在一起。流处理可以在数据到达时转换它。
